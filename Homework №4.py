# Импорт библиотек. Подобная запись позволяет обращаться к библиотечным функциям без упоминания библиотеки, которой эти функции принадлежат
# (это нужно исключительно для удобства использования программы).
from math import *
from random import *

def calc():

    expression = input('>>> ') # Предлагаем пользователю ввести математическое выражение

    if expression.find('stop') != -1: exit() # Если в {expression} нашлось слово stop, то выходим из программы.
    
    # Вообще для выполнения задания, как я понял, нужно было описывать условный блок match case, но мне показалось, что в данной задаче такая заморочка не имеет смысла.
    # Вместо этого программа будет принимать строку от пользователя и передавать её в функцию eval.
    # eval позволяет нам передать в неё какое-то выражение в виде строки и выполнить его, как самый обычный код.
    # В данном случае мы используем именно eval, а не exec, потому что exec не возвращает значение.
    # Блок try нам нужен, чтобы попытаться вывести код, при выполнении которого может произойти ошибка.
    # Чтобы отловить эти ошибки, мы используем блоки except с указанием тех ошибок, которые отлавливаем.
    # Данное решение задачи позволяет нам не парсить строку, а просто выполнять арифметические и логические операции и обрабатывать потенциальные исключения.
    # Вполне возможно, что в данном решении есть и другие исключения, но я обработал только те, что попались мне во время тестирования программы.
    try:

        result = eval(expression)
        print(f' = {result}') # Если в предыдущем выражении не произошла ошибка, то программа просто выводит результат.

    except NameError: print('Ошибка. Вероятно, в введённых вами инструкциях несуществующая функция.')
    except ZeroDivisionError: print('На ноль делить нельзя, олух.')
    except SyntaxError: print('Вы что-то как-то неправильно написали...')

def main():
    
    while True: calc()

if __name__ == '__main__': main()
